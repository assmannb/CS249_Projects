package p3_package;

/**
 * Class wrapper for a Java array, with additional management operations
 * 
 * @author Benjamin Assmann
 * @version 0.2
 */
public class ArrayClass
    {
        private int arrayCapacity;
        private int arraySize;
        private static int DEFAULT_CAPACITY = 10;
        static int FAILED_ACCESS = -999999;
        private int[] localArray;

        ArrayClass()
            {
                localArray = new int[DEFAULT_CAPACITY];
                arrayCapacity = DEFAULT_CAPACITY;
                arraySize = 0;
            }

        ArrayClass(ArrayClass copied)
            {
                int index;
                this.arraySize = copied.arraySize;
                this.arrayCapacity = copied.arrayCapacity;
                localArray = new int[arrayCapacity];

                for (index = 0; index < arraySize; index++)
                    {
                        localArray[index] = copied.localArray[index];
                    }
            }

        ArrayClass(int capacity)
            {
                localArray = new int[capacity];
                arrayCapacity = capacity;
                arraySize = 0;
            }

        ArrayClass(int capacity, int size, int fillValue)
            {
                int index;
                if (capacity < 0)
                    {
                        capacity = DEFAULT_CAPACITY;
                    }
                if (size > capacity)
                    {
                        size = capacity;
                    }
                localArray = new int[capacity];
                arrayCapacity = capacity;
                arraySize = 0;
                for (index = 0; index < size; index++)
                    {
                        localArray[index] = fillValue;
                        arraySize++;
                    }

            }

        int accessItemAt(int accessIndex)
            {
                int accessItem;
                if (accessIndex < arraySize)
                    {
                        accessItem = localArray[accessIndex];
                        return accessItem;
                    }
                return FAILED_ACCESS;
            }

        boolean appendItem(int newValue)
            {
                if (!isFull())
                    {
                        localArray[arraySize] = newValue;
                        arraySize++;
                        return true;
                    }
                return false;
            }

        void clear()
            {
                arraySize = 0;
            }

        private void dump()
            {

            }

        int getCurrentCapacity()
            {
                return arrayCapacity;
            }

        int getCurrentSize()
            {
                return arraySize;
            }

        /**
         * Generates random number between given low and high values
         * 
         * @param low  lowest value that will be generated by method
         * 
         * @param high highest value that will be generated by method
         * 
         * @return the generated random value
         */
        private int getRandBetween(int low, int high)
            {
                int value, range = high - low + 2;

                value = (int) (Math.random() * range);

                return low + value;
            }

        boolean insertItemAt(int insertIndex, int newValue)
            {
                int index;
                if (!isFull())
                    {
                        for (index = arraySize; index > insertIndex; index--)
                            {
                                localArray[index] = localArray[index - 1];
                            }
                        localArray[insertIndex] = newValue;
                        arraySize++;
                        return true;
                    }

                return false;
            }

        boolean isEmpty()
            {
                return arraySize == 0;
            }

        boolean isFull()
            {
                return arraySize >= arrayCapacity;
            }

        boolean isInArray(int testVal)
            {
                int index;
                for (index = 0; index < arraySize; index++)
                    {
                        if (localArray[index] == testVal)
                            {
                                return true;
                            }
                    }
                return false;
            }

        boolean loadUniqueRandoms(int numRands, int lowLimit, int highLimit)
            {

            }

        int removeItemAt(int removeIndex)
            {
                int index;
                if (removeIndex < arraySize)
                    {
                        int index_element = localArray[removeIndex];
                        for (index = removeIndex; index < arraySize; index++)
                            {
                                localArray[index] = localArray[index + 1];
                            }
                        arraySize--;
                        return index_element;
                    }
                return FAILED_ACCESS;
            }

        boolean resize(int newCapacity)
            {
                int index;
                if (newCapacity >= arraySize)
                    {
                        arrayCapacity = newCapacity;
                        int copiedArray[] = new int[arrayCapacity];
                        for (index = 0; index < arraySize; index++)
                            {
                                copiedArray[index] = localArray[index];
                            }
                        localArray = copiedArray;
                        return true;
                    }
                return false;
            }

        private void runMerge(int lowIndex, int middleIndex, int highIndex)
            {

            }

        void runMergeSort()
            {

            }

        private void runMergeSortHelper(int lowIndex, int highIndex)
            {

            }

        private int runPartition(int lowIndex, int highIndex)
            {

            }

        void runQuickSort()
            {

            }

        private void runQuickSortHelper(int lowIndex, int highIndex)
            {

            }

        void runShellSort()
            {
                int gap, gapPassIndex, insertionIndex;
                int tempItem, testItem;
                boolean continueSearch;

                for (gap = arraySize / 2; gap > 0; gap /= 2)
                    {
                        for (gapPassIndex = gap; gapPassIndex < arraySize; gapPassIndex++)
                            {
                                tempItem = localArray[gapPassIndex];

                                insertionIndex = gapPassIndex;

                                continueSearch = true;

                                while (continueSearch && insertionIndex >= gap)
                                    {
                                        testItem = localArray[insertionIndex - gap];

                                        if (testItem > tempItem)
                                            {
                                                localArray[insertionIndex] = localArray[insertionIndex - gap];

                                                insertionIndex -= gap;
                                            }

                                        else
                                            {
                                                continueSearch = false;
                                            }

                                    } // end search loop

                                localArray[insertionIndex] = tempItem;
                            } // end list loop

                    } // end gap size setting loop

            }

        }

        /**
         * swaps values in the object array by taking in the indices of the array
         * locations
         * <p>
         * Note: for a small level of optimization, this method does not swap values if
         * the indices are the same
         * 
         * @param oneIndex   index of the of the values to be swapped
         * 
         * @param otherIndex index of the other value to be swapped
         */
        private void swapValuesAtIndex(int oneIndex, int otherIndex)
            {
                int temp = localArray[oneIndex];

                if (oneIndex != otherIndex)
                    {
                        localArray[oneIndex] = localArray[otherIndex];

                        localArray[otherIndex] = temp;
                    }
            }

    }
